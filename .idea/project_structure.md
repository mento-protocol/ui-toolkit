# Overview

Our existing UI repos, while visually sharing many similarities and UX sharing many identical features, had no established semantics or code sharing strategies in their creation.

This project's objective is to identify, extract & refine/refactor UI & UX features. These can be broken down into the following contexts:

- UI elements such as buttons, code blocks, cards, dropdowns, accordions, etc.
- Theming elements, such as `tailwind` config, brand colors, brand assets, fonts, etc.
- Web3 configurations such as `wagmi` & `rainbow-kit` configurations, ABI & contract interaction hooks
- Utilities such as `prettier`, `eslint`, `cva` & `clsx` for Tailwind
- Minor utilities, such as address shortening, BigInt parsing, etc.

## UI Component Repo Overview

This repo will take learnings from the monorepo investigation and be structured to export various components.

For development, there will be an example folder containing a reference Next.js project. The core idea of this example is to act as an implemented style guide for our brand & shared assets.

The general concept is that this would work closely with a style guide that designers would provide for us to use in future updates, refactors, and products, as well as an example consumer of UI Kit.

## Acceptance Criteria

> Generated by [Zenhub AI](https://www.zenhub.com/ai)

- [ ] **Scenario: Extract and refine UI elements**
- Given the project's objective is to standardize UI elements
- When UI elements are extracted from existing repositories
- Then these elements should be refined, documented, and organized in a shared repo
- [ ] **Scenario: Implement theming elements**
  - Given the need for consistent branding across applications
  - When theming elements such as colors, fonts, and assets are implemented
  - Then these elements should be stored in a central location and used consistently throughout the project
- [ ] **Scenario: Web3 configuration standardization**
  - Given the use of web3 technologies within the applications
  - When `wagmi` & `rainbow kit` configurations are standardized
  - Then these configurations should be shared across all applications and used consistently for interacting with contracts and abis
- [ ] **Scenario: Implement utilities**
  - Given the need for consistent code formatting and styling
  - When prettier, eslint, cva, and clsx are implemented as utilities
  - Then these utilities should be used consistently throughout the project to maintain a cohesive style guide
- [ ] **Scenario: Implement minor utilities**
  - Given the need for specific functionality in certain cases
  - When minor utilities such as address shortening and bigint parsing are implemented
  - Then these utilities should be documented, shared, and used consistently across all applications
